use crate::detectors::{Finding, GroupedFinding, Severity, AnalysisStatistics, Location};
use std::path::Path;
use printpdf::*;
use std::fs::File;
use std::io::BufWriter;
use chrono::Utc;

pub struct PdfReportGenerator {
    title: String,
    project_name: String,
}

impl PdfReportGenerator {
    pub fn new(title: impl Into<String>) -> Self {
        Self {
            title: title.into(),
            project_name: "Sway Smart Contract".to_string(),
        }
    }

    pub fn with_project_info(mut self, project_name: impl Into<String>) -> Self {
        self.project_name = project_name.into();
        self
    }

    pub async fn generate_grouped_report<P: AsRef<Path>>(
        &self,
        grouped_findings: &[GroupedFinding],
        _statistics: &AnalysisStatistics,
        output_path: P,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let (doc, page1, layer1) = PdfDocument::new(&self.title, Mm(210.0), Mm(297.0), "Cover");
        let current_layer = doc.get_page(page1).get_layer(layer1);

        // Load fonts
        let font_bold = doc.add_builtin_font(BuiltinFont::HelveticaBold)?;
        let font_regular = doc.add_builtin_font(BuiltinFont::Helvetica)?;
        let font_mono = doc.add_builtin_font(BuiltinFont::Courier)?;

        let mut y_pos = Mm(250.0);

        // Cover Page
        self.add_cover_page(&current_layer, &font_bold, &font_regular, &mut y_pos)?;

        // Table of Contents
        let (page2, layer2) = doc.add_page(Mm(210.0), Mm(297.0), "Table of Contents");
        let toc_layer = doc.get_page(page2).get_layer(layer2);
        y_pos = Mm(270.0);
        self.add_table_of_contents(&toc_layer, &font_bold, &font_regular, grouped_findings, &mut y_pos)?;

        // Executive Summary
        let (page3, layer3) = doc.add_page(Mm(210.0), Mm(297.0), "Executive Summary");
        let summary_layer = doc.get_page(page3).get_layer(layer3);
        y_pos = Mm(270.0);
        self.add_executive_summary_grouped(&summary_layer, &font_bold, &font_regular, grouped_findings, &mut y_pos)?;

        // Detailed Findings
        let (page4, layer4) = doc.add_page(Mm(210.0), Mm(297.0), "Detailed Findings");
        let findings_layer = doc.get_page(page4).get_layer(layer4);
        y_pos = Mm(270.0);
        self.add_detailed_grouped_findings(&findings_layer, &font_bold, &font_regular, &font_mono, grouped_findings, &mut y_pos, &doc)?;

        // Disclaimer Page
        let (disclaimer_page, disclaimer_layer) = doc.add_page(Mm(210.0), Mm(297.0), "Disclaimer");
        let disclaimer_layer_ref = doc.get_page(disclaimer_page).get_layer(disclaimer_layer);
        y_pos = Mm(270.0);
        self.add_disclaimer_page(&disclaimer_layer_ref, &font_bold, &font_regular, &mut y_pos)?;

        // Save document
        let file = File::create(output_path)?;
        let mut writer = BufWriter::new(file);
        doc.save(&mut writer)?;

        Ok(())
    }

    fn add_cover_page(
        &self,
        layer: &PdfLayerReference,
        font_bold: &IndirectFontRef,
        font_regular: &IndirectFontRef,
        y_pos: &mut Mm,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // Header with logo area
        layer.use_text("SECURITY AUDIT REPORT", 28.0, Mm(20.0), *y_pos, font_bold);
        *y_pos -= Mm(15.0);

        layer.use_text("Comprehensive Sway Smart Contract Analysis", 16.0, Mm(20.0), *y_pos, font_regular);
        *y_pos -= Mm(25.0);

        // Project Information Box
        layer.use_text("┌─────────────────────────────────────────────────────────┐", 12.0, Mm(20.0), *y_pos, font_regular);
        *y_pos -= Mm(8.0);
        layer.use_text("│                    PROJECT INFORMATION                  │", 12.0, Mm(20.0), *y_pos, font_regular);
        *y_pos -= Mm(8.0);
        layer.use_text("└─────────────────────────────────────────────────────────┘", 12.0, Mm(20.0), *y_pos, font_regular);
        *y_pos -= Mm(12.0);

        layer.use_text(&format!("Project Name: {}", self.project_name), 14.0, Mm(25.0), *y_pos, font_bold);
        *y_pos -= Mm(8.0);

        let scan_date = Utc::now().format("%B %d, %Y at %H:%M UTC");
        layer.use_text(&format!("Scan Date: {}", scan_date), 12.0, Mm(25.0), *y_pos, font_regular);
        *y_pos -= Mm(8.0);

        layer.use_text(&format!("Tool Version: SwayScanner v{}", env!("CARGO_PKG_VERSION")), 12.0, Mm(25.0), *y_pos, font_regular);
        *y_pos -= Mm(8.0);

        layer.use_text("Analysis Type: Comprehensive Security Analysis", 12.0, Mm(25.0), *y_pos, font_regular);
        *y_pos -= Mm(25.0);

        // Safe Edges Branding
        layer.use_text("Generated by SwayScanner", 18.0, Mm(20.0), *y_pos, font_bold);
        *y_pos -= Mm(10.0);
        layer.use_text("Built by Safe Edges Team", 14.0, Mm(20.0), *y_pos, font_regular);
        *y_pos -= Mm(8.0);
        layer.use_text("Securing the Decentralized Future", 12.0, Mm(20.0), *y_pos, font_regular);
        *y_pos -= Mm(15.0);

        // Contact Information
        layer.use_text("Contact Information:", 12.0, Mm(20.0), *y_pos, font_bold);
        *y_pos -= Mm(8.0);
        layer.use_text("Website: https://safeedges.in", 10.0, Mm(25.0), *y_pos, font_regular);
        *y_pos -= Mm(6.0);
        layer.use_text("Email: info@safeedges.in", 10.0, Mm(25.0), *y_pos, font_regular);
        *y_pos -= Mm(6.0);
        layer.use_text("Support: Contact us for professional security audits", 10.0, Mm(25.0), *y_pos, font_regular);
        *y_pos -= Mm(20.0);

        // Report Classification
        layer.use_text("┌─────────────────────────────────────────────────────────┐", 12.0, Mm(20.0), *y_pos, font_regular);
        *y_pos -= Mm(8.0);
        layer.use_text("│                  REPORT CLASSIFICATION                  │", 12.0, Mm(20.0), *y_pos, font_regular);
        *y_pos -= Mm(8.0);
        layer.use_text("└─────────────────────────────────────────────────────────┘", 12.0, Mm(20.0), *y_pos, font_regular);
        *y_pos -= Mm(10.0);

        layer.use_text("Confidentiality: Internal Use", 10.0, Mm(25.0), *y_pos, font_regular);
        *y_pos -= Mm(6.0);
        layer.use_text("Distribution: Authorized Personnel Only", 10.0, Mm(25.0), *y_pos, font_regular);
        *y_pos -= Mm(6.0);
        layer.use_text("Version: 1.0", 10.0, Mm(25.0), *y_pos, font_regular);

        Ok(())
    }

    fn add_table_of_contents(
        &self,
        layer: &PdfLayerReference,
        font_bold: &IndirectFontRef,
        font_regular: &IndirectFontRef,
        grouped_findings: &[GroupedFinding],
        y_pos: &mut Mm,
    ) -> Result<(), Box<dyn std::error::Error>> {
        layer.use_text("TABLE OF CONTENTS", 20.0, Mm(20.0), *y_pos, font_bold);
        *y_pos -= Mm(20.0);

        let toc_items = vec![
            ("1. Executive Summary", "3"),
            ("2. Vulnerability Overview", "4"),
            ("3. Detailed Findings", "5"),
            ("   3.1 Critical Severity Issues", "6"),
            ("   3.2 High Severity Issues", "8"),
            ("   3.3 Medium Severity Issues", "12"),
            ("   3.4 Low Severity Issues", "15"),
            ("4. Recommendations", "18"),
            ("5. Methodology", "19"),
            ("6. Disclaimer", "20"),
        ];

        for (item, page) in toc_items {
            layer.use_text(item, 12.0, Mm(25.0), *y_pos, font_regular);
            
            // Add dots
            let dots = ".".repeat(50 - item.len());
            layer.use_text(&dots, 12.0, Mm(25.0 + (item.len() as f32 * 2.5)), *y_pos, font_regular);
            
            layer.use_text(page, 12.0, Mm(180.0), *y_pos, font_regular);
            *y_pos -= Mm(8.0);
        }

        *y_pos -= Mm(20.0);

        // Vulnerability Summary for TOC
        layer.use_text("VULNERABILITY SUMMARY", 14.0, Mm(20.0), *y_pos, font_bold);
        *y_pos -= Mm(10.0);

        let critical_count = grouped_findings.iter().filter(|g| matches!(g.severity, Severity::Critical)).count();
        let high_count = grouped_findings.iter().filter(|g| matches!(g.severity, Severity::High)).count();
        let medium_count = grouped_findings.iter().filter(|g| matches!(g.severity, Severity::Medium)).count();
        let low_count = grouped_findings.iter().filter(|g| matches!(g.severity, Severity::Low)).count();

        layer.use_text(&format!("Critical Severity Issues: {}", critical_count), 12.0, Mm(25.0), *y_pos, font_regular);
        *y_pos -= Mm(6.0);
        layer.use_text(&format!("High Severity Issues: {}", high_count), 12.0, Mm(25.0), *y_pos, font_regular);
        *y_pos -= Mm(6.0);
        layer.use_text(&format!("Medium Severity Issues: {}", medium_count), 12.0, Mm(25.0), *y_pos, font_regular);
        *y_pos -= Mm(6.0);
        layer.use_text(&format!("Low Severity Issues: {}", low_count), 12.0, Mm(25.0), *y_pos, font_regular);
        *y_pos -= Mm(6.0);

        let total_issues = critical_count + high_count + medium_count + low_count;
        layer.use_text(&format!("Total Issues Found: {}", total_issues), 12.0, Mm(25.0), *y_pos, font_bold);

        Ok(())
    }

    fn add_executive_summary_grouped(
        &self,
        layer: &PdfLayerReference,
        font_bold: &IndirectFontRef,
        font_regular: &IndirectFontRef,
        grouped_findings: &[GroupedFinding],
        y_pos: &mut Mm,
    ) -> Result<(), Box<dyn std::error::Error>> {
        layer.use_text("EXECUTIVE SUMMARY", 20.0, Mm(20.0), *y_pos, font_bold);
        *y_pos -= Mm(15.0);

        // Overview
        layer.use_text("SECURITY ASSESSMENT OVERVIEW", 14.0, Mm(20.0), *y_pos, font_bold);
        *y_pos -= Mm(10.0);

        let overview_text = format!(
            "This report presents the findings of a comprehensive security analysis of the {} \
            smart contract conducted using SwayScanner, an advanced static analysis tool \
            specifically designed for Sway smart contracts on the Fuel blockchain. \
            The analysis identified {} unique vulnerability types across {} total occurrences.",
            self.project_name,
            grouped_findings.len(),
            grouped_findings.iter().map(|g| g.occurrence_count).sum::<usize>()
        );

        self.add_wrapped_text(layer, font_regular, &overview_text, Mm(20.0), y_pos, Mm(170.0), 12.0);
        *y_pos -= Mm(15.0);

        // Risk Assessment
        layer.use_text("RISK ASSESSMENT", 14.0, Mm(20.0), *y_pos, font_bold);
        *y_pos -= Mm(10.0);

        let critical_count = grouped_findings.iter().filter(|g| matches!(g.severity, Severity::Critical)).count();
        let high_count = grouped_findings.iter().filter(|g| matches!(g.severity, Severity::High)).count();
        let medium_count = grouped_findings.iter().filter(|g| matches!(g.severity, Severity::Medium)).count();
        let low_count = grouped_findings.iter().filter(|g| matches!(g.severity, Severity::Low)).count();

        // Overall Risk Level
        let risk_level = if critical_count > 0 {
            "CRITICAL RISK"
        } else if high_count > 3 {
            "HIGH RISK"
        } else if high_count > 0 || medium_count > 5 {
            "MEDIUM RISK"
        } else {
            "LOW RISK"
        };

        layer.use_text(&format!("Overall Risk Level: {}", risk_level), 12.0, Mm(20.0), *y_pos, font_bold);
        *y_pos -= Mm(10.0);

        // Severity Breakdown
        layer.use_text("Severity Breakdown:", 12.0, Mm(20.0), *y_pos, font_bold);
        *y_pos -= Mm(8.0);

        if critical_count > 0 {
            layer.use_text(&format!("• Critical Issues: {} - Immediate action required", critical_count), 11.0, Mm(25.0), *y_pos, font_regular);
            *y_pos -= Mm(6.0);
        }
        if high_count > 0 {
            layer.use_text(&format!("• High Issues: {} - Fix before deployment", high_count), 11.0, Mm(25.0), *y_pos, font_regular);
            *y_pos -= Mm(6.0);
        }
        if medium_count > 0 {
            layer.use_text(&format!("• Medium Issues: {} - Address when possible", medium_count), 11.0, Mm(25.0), *y_pos, font_regular);
            *y_pos -= Mm(6.0);
        }
        if low_count > 0 {
            layer.use_text(&format!("• Low Issues: {} - Consider fixing", low_count), 11.0, Mm(25.0), *y_pos, font_regular);
            *y_pos -= Mm(6.0);
        }

        *y_pos -= Mm(10.0);

        // Key Recommendations
        layer.use_text("KEY RECOMMENDATIONS", 14.0, Mm(20.0), *y_pos, font_bold);
        *y_pos -= Mm(10.0);

        let recommendations = if critical_count > 0 || high_count > 0 {
            vec![
                "1. Address all critical and high-severity vulnerabilities immediately",
                "2. Conduct thorough testing after implementing fixes", 
                "3. Consider professional security audit before deployment",
                "4. Implement comprehensive access controls",
                "5. Add proper input validation and error handling",
                "6. Re-run security analysis to verify fixes"
            ]
        } else if medium_count > 0 {
            vec![
                "1. Review and address medium-severity issues",
                "2. Test fixes thoroughly in development environment",
                "3. Maintain good security practices",
                "4. Consider automated security scanning in CI/CD"
            ]
        } else {
            vec![
                "1. Address remaining low-severity issues when possible",
                "2. Maintain current security standards",
                "3. Regular security assessments recommended"
            ]
        };

        for recommendation in recommendations {
            layer.use_text(recommendation, 11.0, Mm(25.0), *y_pos, font_regular);
            *y_pos -= Mm(6.0);
        }

        Ok(())
    }

    fn add_detailed_grouped_findings(
        &self,
        layer: &PdfLayerReference,
        font_bold: &IndirectFontRef,
        font_regular: &IndirectFontRef,
        font_mono: &IndirectFontRef,
        grouped_findings: &[GroupedFinding],
        y_pos: &mut Mm,
        doc: &PdfDocumentReference,
    ) -> Result<(), Box<dyn std::error::Error>> {
        layer.use_text("DETAILED FINDINGS", 20.0, Mm(20.0), *y_pos, font_bold);
        *y_pos -= Mm(15.0);

        // Sort findings by severity (Critical -> High -> Medium -> Low)
        let mut sorted_findings = grouped_findings.to_vec();
        sorted_findings.sort_by(|a, b| {
            let severity_order = |s: &Severity| match s {
                Severity::Critical => 0,
                Severity::High => 1,
                Severity::Medium => 2,
                Severity::Low => 3,
            };
            severity_order(&a.severity).cmp(&severity_order(&b.severity))
        });

        for (i, group) in sorted_findings.iter().enumerate() {
            // Check if we need a new page
            if *y_pos < Mm(50.0) {
                let (new_page, new_layer) = doc.add_page(Mm(210.0), Mm(297.0), "Findings Continued");
                let new_layer_ref = doc.get_page(new_page).get_layer(new_layer);
                *y_pos = Mm(270.0);
                return self.add_detailed_grouped_findings(&new_layer_ref, font_bold, font_regular, font_mono, &sorted_findings[i..], y_pos, doc);
            }

            // Finding header with severity indicator
            let severity_prefix = match group.severity {
                Severity::Critical => "[CRITICAL]",
                Severity::High => "[HIGH]",
                Severity::Medium => "[MEDIUM]",
                Severity::Low => "[LOW]",
            };

            layer.use_text(&format!("{} Finding #{}: {}", severity_prefix, i + 1, group.title), 14.0, Mm(20.0), *y_pos, font_bold);
            *y_pos -= Mm(8.0);

            // Metadata
            layer.use_text(&format!("Detector: {} | Occurrences: {} | Confidence: {:.0}%", 
                self.format_detector_name(&group.detector_name),
                group.occurrence_count, 
                group.confidence * 100.0), 10.0, Mm(20.0), *y_pos, font_regular);
            *y_pos -= Mm(6.0);

            if !group.cwe_ids.is_empty() {
                layer.use_text(&format!("CWE IDs: {}", 
                    group.cwe_ids.iter().map(|id| format!("CWE-{}", id)).collect::<Vec<_>>().join(", ")), 
                    10.0, Mm(20.0), *y_pos, font_regular);
                *y_pos -= Mm(8.0);
            }

            // Description
            layer.use_text("Description:", 12.0, Mm(20.0), *y_pos, font_bold);
            *y_pos -= Mm(6.0);
            self.add_wrapped_text(layer, font_regular, &group.description, Mm(25.0), y_pos, Mm(165.0), 10.0);
            *y_pos -= Mm(8.0);

            // Locations
            layer.use_text(&format!("Affected Locations ({} occurrences):", group.locations.len()), 12.0, Mm(20.0), *y_pos, font_bold);
            *y_pos -= Mm(6.0);

            for (_loc_idx, location) in group.locations.iter().enumerate().take(5) { // Limit to 5 locations for space
                layer.use_text(&format!("• {}:{}", location.file_path, location.line), 10.0, Mm(25.0), *y_pos, font_mono);
                *y_pos -= Mm(5.0);
                
                if !location.code_snippet.is_empty() {
                    let code_snippet = if location.code_snippet.len() > 80 {
                        format!("{}...", &location.code_snippet[..77])
                    } else {
                        location.code_snippet.clone()
                    };
                    layer.use_text(&format!("  Code: {}", code_snippet), 9.0, Mm(30.0), *y_pos, font_mono);
                    *y_pos -= Mm(5.0);
                }
            }

            if group.locations.len() > 5 {
                layer.use_text(&format!("  ... and {} more locations", group.locations.len() - 5), 10.0, Mm(25.0), *y_pos, font_regular);
                *y_pos -= Mm(5.0);
            }

            *y_pos -= Mm(5.0);

            // Impact
            if !group.impact.is_empty() {
                layer.use_text("Impact:", 12.0, Mm(20.0), *y_pos, font_bold);
                *y_pos -= Mm(6.0);
                self.add_wrapped_text(layer, font_regular, &group.impact, Mm(25.0), y_pos, Mm(165.0), 10.0);
                *y_pos -= Mm(8.0);
            }

            // Recommendation
            if !group.recommendation.is_empty() {
                layer.use_text("Recommendation:", 12.0, Mm(20.0), *y_pos, font_bold);
                *y_pos -= Mm(6.0);
                self.add_wrapped_text(layer, font_regular, &group.recommendation, Mm(25.0), y_pos, Mm(165.0), 10.0);
                *y_pos -= Mm(8.0);
            }

            // References
            if !group.references.is_empty() {
                layer.use_text("References:", 12.0, Mm(20.0), *y_pos, font_bold);
                *y_pos -= Mm(6.0);
                for reference in &group.references {
                    layer.use_text(&format!("• {} - {}", reference.title, reference.url), 9.0, Mm(25.0), *y_pos, font_regular);
                    *y_pos -= Mm(5.0);
                }
                *y_pos -= Mm(5.0);
            }

            // Separator
            if i < sorted_findings.len() - 1 {
                layer.use_text("─".repeat(80), 10.0, Mm(20.0), *y_pos, font_mono);
                *y_pos -= Mm(10.0);
            }
        }

        Ok(())
    }

    fn add_disclaimer_page(
        &self,
        layer: &PdfLayerReference,
        font_bold: &IndirectFontRef,
        font_regular: &IndirectFontRef,
        y_pos: &mut Mm,
    ) -> Result<(), Box<dyn std::error::Error>> {
        layer.use_text("DISCLAIMER", 20.0, Mm(20.0), *y_pos, font_bold);
        *y_pos -= Mm(20.0);

        let disclaimer_sections = vec![
            ("SCOPE OF ANALYSIS", vec![
                "This security audit report has been generated using SwayScanner, an automated static analysis tool designed for Sway smart contracts. The analysis focuses on identifying common security vulnerabilities, code quality issues, and best practice violations.",
                "",
                "The scope of this analysis includes but is not limited to: access control vulnerabilities, reentrancy attacks, input validation issues, business logic flaws, cryptographic weaknesses, and potential denial of service vectors."
            ]),
            ("LIMITATIONS", vec![
                "• This is an automated analysis and may not catch all possible vulnerabilities",
                "• Complex business logic vulnerabilities may require manual review",
                "• The analysis is based on static code examination without runtime testing",
                "• External dependencies and integrations are not fully analyzed",
                "• Novel attack vectors not covered by current detection rules may be missed"
            ]),
            ("RECOMMENDATIONS", vec![
                "• This report should be supplemented with manual security review",
                "• Comprehensive testing should be performed after addressing findings",
                "• Consider professional security audit for high-value applications",
                "• Regular security assessments are recommended throughout development",
                "• Keep up-to-date with latest Sway security best practices"
            ]),
            ("LIABILITY", vec![
                "Safe Edges Team and SwayScanner provide this analysis tool and report 'as is' without warranty of any kind. The use of this tool and reliance on this report is at your own risk.",
                "",
                "Safe Edges Team shall not be liable for any damages, losses, or security breaches that may occur despite the use of this analysis tool. The responsibility for ensuring smart contract security ultimately lies with the development team and project stakeholders."
            ]),
            ("ABOUT SAFE EDGES", vec![
                "Safe Edges is dedicated to securing the decentralized future through advanced security tooling and professional audit services. Our team specializes in blockchain security, smart contract auditing, and security tool development.",
                "",
                "For professional security audit services, custom security solutions, or enterprise support, please contact us at info@safeedges.in or visit https://safeedges.in"
            ])
        ];

        for (section_title, section_content) in disclaimer_sections {
            layer.use_text(section_title, 14.0, Mm(20.0), *y_pos, font_bold);
            *y_pos -= Mm(10.0);

            for paragraph in section_content {
                if paragraph.is_empty() {
                    *y_pos -= Mm(5.0);
                    continue;
                }

                if paragraph.starts_with('•') {
                    layer.use_text(paragraph, 11.0, Mm(25.0), *y_pos, font_regular);
                    *y_pos -= Mm(6.0);
                } else {
                    self.add_wrapped_text(layer, font_regular, paragraph, Mm(25.0), y_pos, Mm(165.0), 11.0);
                    *y_pos -= Mm(8.0);
                }
            }

            *y_pos -= Mm(10.0);
        }

        // Footer with contact information
        *y_pos = Mm(40.0);
        layer.use_text("Contact Information:", 12.0, Mm(20.0), *y_pos, font_bold);
        *y_pos -= Mm(8.0);
        layer.use_text("Safe Edges Team", 11.0, Mm(20.0), *y_pos, font_regular);
        *y_pos -= Mm(6.0);
        layer.use_text("Email: info@safeedges.in", 11.0, Mm(20.0), *y_pos, font_regular);
        *y_pos -= Mm(6.0);
        layer.use_text("Website: https://safeedges.in", 11.0, Mm(20.0), *y_pos, font_regular);
        *y_pos -= Mm(6.0);
        layer.use_text(&format!("Report Generated: {}", Utc::now().format("%Y-%m-%d %H:%M:%S UTC")), 10.0, Mm(20.0), *y_pos, font_regular);

        Ok(())
    }

    fn add_wrapped_text(
        &self,
        layer: &PdfLayerReference,
        font: &IndirectFontRef,
        text: &str,
        x_pos: Mm,
        y_pos: &mut Mm,
        max_width: Mm,
        font_size: f32,
    ) {
        let words: Vec<&str> = text.split_whitespace().collect();
        let mut current_line = String::new();
        let char_width = font_size * 0.6; // Approximate character width
        let max_chars = (max_width.0 / char_width) as usize;

        for word in words {
            if current_line.len() + word.len() + 1 > max_chars && !current_line.is_empty() {
                layer.use_text(&current_line, font_size, x_pos, *y_pos, font);
                *y_pos -= Mm(font_size * 0.4);
                current_line.clear();
            }

            if !current_line.is_empty() {
                current_line.push(' ');
            }
            current_line.push_str(word);
        }

        if !current_line.is_empty() {
            layer.use_text(&current_line, font_size, x_pos, *y_pos, font);
            *y_pos -= Mm(font_size * 0.4);
        }
    }

    fn format_detector_name(&self, name: &str) -> String {
        match name {
            "access_control" => "Access Control",
            "reentrancy_vulnerability" => "Reentrancy Attack", 
            "input_validation" => "Input Validation",
            "data_validation" => "Data Validation",
            "unchecked_external_calls" => "Unchecked External Calls",
            "unprotected_storage_variable" => "Unprotected Storage",
            "business_logic" => "Business Logic",
            "cryptographic_issues" => "Cryptographic Issues",
            "price_oracle_manipulation" => "Price Oracle Manipulation",
            "flash_loan_attacks" => "Flash Loan Attacks",
            "utxo_vulnerabilities" => "UTXO Vulnerabilities",
            "logic_errors" => "Logic Errors",
            _ => name
        }.to_string()
    }

    // Legacy method for ungrouped findings
    pub async fn generate_report<P: AsRef<Path>>(
        &self,
        findings: &[Finding],
        statistics: &AnalysisStatistics,
        output_path: P,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // Convert findings to grouped format for consistency
        let grouped_findings = self.group_findings_for_report(findings);
        self.generate_grouped_report(&grouped_findings, statistics, output_path).await
    }

    fn group_findings_for_report(&self, findings: &[Finding]) -> Vec<GroupedFinding> {
        let mut groups = std::collections::HashMap::new();
        
        for finding in findings {
            let key = (&finding.detector_name, &finding.title, &finding.severity);
            groups.entry(key).or_insert_with(Vec::new).push(finding);
        }

        groups.into_iter().map(|((detector_name, title, severity), findings)| {
            let first_finding = &findings[0];
            GroupedFinding {
                id: first_finding.id.clone(),
                created_at: first_finding.created_at,
                detector_name: detector_name.clone(),
                title: title.clone(),
                severity: severity.clone(),
                category: first_finding.category.clone(),
                confidence: findings.iter().map(|f| f.confidence).sum::<f64>() / findings.len() as f64,
                description: first_finding.description.clone(),
                recommendation: first_finding.recommendation.clone(),
                impact: first_finding.impact.clone(),
                effort: first_finding.effort.clone(),
                references: first_finding.references.clone(),
                cwe_ids: first_finding.cwe_ids.clone(),
                owasp_category: first_finding.owasp_category.clone(),
                tags: first_finding.tags.clone(),
                occurrence_count: findings.len(),
                locations: findings.iter().map(|f| Location {
                    file_path: f.file_path.clone(),
                    line: f.line,
                    column: f.column,
                    end_line: f.end_line,
                    end_column: f.end_column,
                    code_snippet: f.code_snippet.clone(),
                    function_name: f.context.function_name.clone(),
                }).collect(),
                fingerprint: first_finding.fingerprint.clone(),
                context: first_finding.context.clone(),
            }
        }).collect()
    }
} 