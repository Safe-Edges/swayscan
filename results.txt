SwayScanner Analysis Report
══════════════════════════════════════════════════════
10 findings found:

[Critical] Potential Reentrancy Vulnerability (5 occurrences) (reentrancy_vulnerability)
   Location: E:\swayscan\examples\test_reentrancy.sw:33
   Description: External call at line 33 may allow reentrancy attack. State changes detected after external call: Line 36: storage.balances.insert(. This pattern can allow an attacker to call back into the contract before state changes are finalized.

Found in 5 locations:
  • test_reentrancy.sw:33 - 30:     require(balance >= amount, "Insufficient balance");
  • test_reentrancy.sw:83 - 80:     require(balance >= amount * 2, "Insufficient balance");
  • test_reentrancy.sw:84 - 81:
  • vulnerable_contract.sw:112 - 109:         // BAD: No amount validation
  • vulnerable_contract.sw:186 - 183:     #[storage(read, write)]
   Code:     30:     require(balance >= amount, "Insufficient balance");
    31:     
    32:     // VULNERABLE: External call before state update
>>> 33:     transfer(Identity::Address(sender), AssetId::base(), amount);
    34:     
    35:     // VULNERABLE: State change after external call
    36:     storage.balances.insert(sender, balance - amount);
   Recommendation: Implement the checks-effects-interactions pattern: (1) Perform all checks, (2) Make state changes, (3) Interact with external contracts. Consider using a reentrancy guard or mutex.

[High] Unprotected Storage Modification (9 occurrences) (unprotected_storage_variable)
   Location: E:\swayscan\examples\test_access_control.sw:31
   Description: Storage variable is modified without proper access control

Found in 9 locations:
  • test_access_control.sw:31 - 29:     // VULNERABLE: No access control check
  • test_access_control.sw:45 - 43:
  • test_access_control.sw:64 - 62:
  • test_reentrancy.sw:60 - 58:     // SECURE: Reentrancy guard
  • test_reentrancy.sw:71 - 69:
  • vulnerable_contract.sw:125 - 123:
  • vulnerable_contract.sw:143 - 141:         require(amount <= 1000000, "Amount too large");
  • vulnerable_contract.sw:158 - 156:         if price > 1000000 {
  • vulnerable_contract.sw:302 - 300:     fn unsafe_write_function(value: u64) {
   Code:     29:     // VULNERABLE: No access control check
    30:     let current_supply = storage.total_supply.read();
>>> 31:     storage.total_supply.write(current_supply + amount);
    32:     
    33:     let balance = storage.balances.get(to).try_read().unwrap_or(0);
   Recommendation: Add access control checks before modifying storage variables

[High] Insufficient Input Validation (7 occurrences) (input_validation)
   Location: E:\swayscan\examples\test_reentrancy.sw:57
   Description: Function at line 57 accepts parameters fn guarded_withdraw(amount: u64) but performs dangerous operations without sufficient validation: storage write, transfer, storage write. Risk factors: Financial operation context, High-risk operations present, Missing input bounds validation, Missing overflow protection. Unvalidated inputs can lead to vulnerabilities.

Found in 7 locations:
  • test_reentrancy.sw:57 - 54:
  • test_reentrancy.sw:76 - 73:
  • test_reentrancy.sw:76 - 73:
  • test_reentrancy.sw:92 - 89:
  • vulnerable_contract.sw:184 - 181:
  • vulnerable_contract.sw:184 - 181:
  • vulnerable_contract.sw:300 - 297:     }
   Code:     54: 
    55: // TEST 3: Reentrancy guard pattern - SHOULD NOT be flagged
    56: #[storage(read, write)]
>>> 57: fn guarded_withdraw(amount: u64) {
    58:     // SECURE: Reentrancy guard
    59:     require(!storage.locked.read(), "Reentrant call");
    60:     storage.locked.write(true);
   Recommendation: Implement comprehensive input validation: (1) Add require() statements for parameter bounds, (2) Check for zero addresses/IDs, (3) Validate ranges before arithmetic operations, (4) Use checked arithmetic for financial calculations, (5) Add parameter sanitization for arrays/loops.

[High] Missing Input Validation (5 occurrences) (data_validation)
   Location: E:\swayscan\examples\test_reentrancy.sw:57
   Description: Function parameter 'fn guarded_withdraw(amount: u64' is used in security-critical operations without proper validation. This could lead to unexpected behavior or vulnerabilities.

Found in 5 locations:
  • test_reentrancy.sw:57 - 54:
  • test_reentrancy.sw:76 - 73:
  • test_reentrancy.sw:76 - 73:
  • vulnerable_contract.sw:184 - 181:
  • vulnerable_contract.sw:300 - 297:     }
   Code:     54: 
    55: // TEST 3: Reentrancy guard pattern - SHOULD NOT be flagged
    56: #[storage(read, write)]
>>> 57: fn guarded_withdraw(amount: u64) {
    58:     // SECURE: Reentrancy guard
    59:     require(!storage.locked.read(), "Reentrant call");
    60:     storage.locked.write(true);
   Recommendation: Add input validation using require() statements to check parameter bounds, non-zero values, valid addresses, and other constraints before using parameters in critical operations.

[High] External Call in Loop (5 occurrences) (business_logic)
   Location: E:\swayscan\examples\test_reentrancy.sw:32
   Description: Loop containing external calls detected. This pattern can lead to gas exhaustion, reentrancy attacks, or DoS conditions.

Found in 5 locations:
  • test_reentrancy.sw:32 - 30:     require(balance >= amount, "Insufficient balance");
  • test_reentrancy.sw:82 - 80:     require(balance >= amount * 2, "Insufficient balance");
  • vulnerable_contract.sw:96 - 94:         require(balance >= amount, "Insufficient balance");
  • vulnerable_contract.sw:111 - 109:         // BAD: No amount validation
  • vulnerable_contract.sw:185 - 183:     #[storage(read, write)]
   Code:     30:     require(balance >= amount, "Insufficient balance");
    31:     
>>> 32:     // VULNERABLE: External call before state update
    33:     transfer(Identity::Address(sender), AssetId::base(), amount);
    34:     
   Recommendation: Avoid external calls in loops. Use pull-over-push pattern, batch operations, or implement proper gas limits and bounds checking.

[High] Unchecked External Call (unchecked_external_calls)
   Location: E:\swayscan\examples\vulnerable_contract.sw:32
   Description: Asset transfer at line 32 does not check return value or handle potential failures. Call: 'transfer(to: Identity, amount: u64);'. Risk factors: High-risk financial operation, Financial context. Failed external calls can cause unexpected behavior or loss of funds.
   Code:     30:     // TEST 1: PROPERLY VALIDATED FUNCTION (should NOT trigger)
    31:     #[storage(read, write)]
>>> 32:     fn secure_transfer(to: Identity, amount: u64);
    33:     
    34:     // TEST 2: UNVALIDATED FINANCIAL FUNCTION (should trigger high severity)
   Recommendation: Handle external call results properly: (1) Assign return value and check for success, (2) Use match statement for Result types, (3) Add require() or assert() for critical calls, (4) Consider using try-catch equivalent patterns. Example: let result = transfer(...); require(result.is_ok(), "Call failed");

[High] Insecure Randomness Source (cryptographic_issues)
   Location: E:\swayscan\examples\vulnerable_contract.sw:241
   Description: Using predictable or weak randomness source: timestamp for rand. This can lead to predictable outcomes in security-critical operations.
   Code:     239:     // TEST 8: CRYPTOGRAPHIC - WEAK
    240:     fn weak_random_generator() -> u64 {
>>> 241:         // BAD: Using timestamp for randomness
    242:         let timestamp = std::block::timestamp();
    243:         let sender_bytes = std::tx::tx_id();
   Recommendation: Use a cryptographically secure random number generator (CSPRNG) or commit-reveal schemes for randomness in smart contracts.

[Medium] Missing Bounds Checking (25 occurrences) (data_validation)
   Location: E:\swayscan\examples\test_access_control.sw:33
   Description: Array or collection access 'get(to)' without bounds checking. This could lead to out-of-bounds access or panic conditions.

Found in 25 locations:
  • test_access_control.sw:33 - 31:     storage.total_supply.write(current_supply + amount);
  • test_access_control.sw:34 - 32:
  • test_access_control.sw:47 - 45:     storage.total_supply.write(current_supply + amount);
  • test_access_control.sw:48 - 46:
  • test_access_control.sw:71 - 69: fn get_balance(user: Address) -> u64 {
  • test_reentrancy.sw:36 - 34:
  • test_reentrancy.sw:49 - 47:
  • test_reentrancy.sw:87 - 85:
  • test_reentrancy.sw:94 - 92: fn safe_balance_check(user: Address) -> u64 {
  • vulnerable_contract.sw:97 - 95:
  • vulnerable_contract.sw:98 - 96:         // GOOD: State changes before external calls
  • vulnerable_contract.sw:98 - 96:         // GOOD: State changes before external calls
  • vulnerable_contract.sw:114 - 112:         transfer(caller, AssetId::base(), amount);
  • vulnerable_contract.sw:115 - 113:
  • vulnerable_contract.sw:127 - 125:         storage.total_supply.write(current_supply + amount); // Can overflow
  • vulnerable_contract.sw:128 - 126:
  • vulnerable_contract.sw:153 - 151:         // BAD: No staleness check
  • vulnerable_contract.sw:179 - 177:         );
  • vulnerable_contract.sw:189 - 187:
  • vulnerable_contract.sw:190 - 188:         // BAD: State change after external call
  • vulnerable_contract.sw:204 - 202:
  • vulnerable_contract.sw:213 - 211:     #[storage(read, write)]
  • vulnerable_contract.sw:214 - 212:     fn risky_liquidation(user: Identity, asset: AssetId) {
  • vulnerable_contract.sw:221 - 219:         if collateral * price < 150000000 { // Magic number
  • vulnerable_contract.sw:231 - 229:     #[storage(read)]
   Code:     31:     storage.total_supply.write(current_supply + amount);
    32:     
>>> 33:     let balance = storage.balances.get(to).try_read().unwrap_or(0);
    34:     storage.balances.insert(to, balance + amount);
    35: }
   Recommendation: Add bounds checking before array access using length checks or use safe access methods that return Option types.

[Medium] Missing Zero Address Check (6 occurrences) (data_validation)
   Location: E:\swayscan\examples\test_access_control.sw:53
   Description: Operation using address parameter without checking for zero address. This could lead to permanent loss of assets.

Found in 6 locations:
  • test_access_control.sw:53 - 51: // TEST 3: Admin access control - SHOULD NOT be flagged
  • test_reentrancy.sw:33 - 31:
  • test_reentrancy.sw:52 - 50:
  • test_reentrancy.sw:68 - 66:
  • test_reentrancy.sw:83 - 81:
  • test_reentrancy.sw:84 - 82:     // VULNERABLE: External calls before state update
   Code:     51: // TEST 3: Admin access control - SHOULD NOT be flagged
    52: #[storage(read, write)]  
>>> 53: fn secure_admin_burn(from: Address, amount: u64) {
    54:     // SECURE: Admin check
    55:     let sender = msg_sender().unwrap().as_address().unwrap();
   Recommendation: Add require(address != Address::zero()) to prevent operations with zero addresses.

[Medium] Missing Zero Amount Check (2 occurrences) (data_validation)
   Location: E:\swayscan\examples\vulnerable_contract.sw:32
   Description: Transfer operation without checking for zero amount. This wastes gas and may indicate logical errors.

Found in 2 locations:
  • vulnerable_contract.sw:32 - 30:     // TEST 1: PROPERLY VALIDATED FUNCTION (should NOT trigger)
  • vulnerable_contract.sw:80 - 78:     // TEST 1: PROPERLY VALIDATED FUNCTION
   Code:     30:     // TEST 1: PROPERLY VALIDATED FUNCTION (should NOT trigger)
    31:     #[storage(read, write)]
>>> 32:     fn secure_transfer(to: Identity, amount: u64);
    33:     
    34:     // TEST 2: UNVALIDATED FINANCIAL FUNCTION (should trigger high severity)
   Recommendation: Add require(amount > 0) before transfer operations to prevent zero-value transfers.

══════════════════════════════════════════════════════
Analysis completed by SwayScanner
